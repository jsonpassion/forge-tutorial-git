# 빌드와 테스트 자동화

> CI 파이프라인 구축, 매트릭스 빌드, 캐싱

## 개요

워크플로우 YAML 문법을 배웠으니, 이제 실전에서 가장 많이 사용하는 **CI(Continuous Integration) 파이프라인**을 구축해봅시다. 코드를 push하면 자동으로 빌드하고, 테스트하고, 여러 환경에서 검증하는 것 — 이것이 현대 소프트웨어 개발의 기본 중 기본입니다.

**선수 지식**: [워크플로우 작성](./02-workflow-yaml.md)의 트리거, 환경 변수, 시크릿
**학습 목표**:
- CI의 개념과 중요성을 이해한다
- 매트릭스 빌드로 여러 환경을 동시에 테스트한다
- 캐싱으로 워크플로우 실행 시간을 단축한다
- 실전 CI 파이프라인을 직접 구축한다

## 왜 알아야 할까?

"내 컴퓨터에서는 잘 되는데요?" — 개발자라면 한 번쯤 해본 말이죠. CI는 이 문제를 근본적으로 해결합니다. 코드가 push될 때마다 **깨끗한 환경**에서 자동으로 빌드/테스트가 실행되니까요. [워크플로우 전략](../08-advanced-branch/04-workflow-strategies.md)에서 배웠듯, GitHub Flow나 Trunk-Based Development에서 CI는 **필수**입니다.

## 핵심 개념

### 개념 1: CI란?

> 💡 **비유**: CI는 **자동 품질 검사관**입니다. 공장에서 제품이 만들어질 때마다 자동으로 검사하는 것처럼, 코드가 변경될 때마다 "이 코드가 정상 작동하는지" 자동으로 확인합니다. 불량품(버그)이 고객에게 도달하기 전에 잡아내는 거죠.

**Continuous Integration**(지속적 통합)은 개발자가 코드를 자주 병합(통합)하고, 매번 자동으로 빌드/테스트를 실행하는 개발 방식입니다.

CI의 핵심 원칙:
1. **자주 통합**: 작은 변경을 자주 병합한다
2. **자동 검증**: 모든 변경은 자동 빌드/테스트를 통과해야 한다
3. **빠른 피드백**: 문제가 있으면 즉시 개발자에게 알린다
4. **깨끗한 환경**: 매번 새로운 환경에서 실행한다

### 개념 2: CI 파이프라인 기본 구조

전형적인 CI 파이프라인의 단계를 알아봅시다:

**코드 체크아웃** → **환경 설정** → **의존성 설치** → **린트/포맷** → **테스트** → **빌드**

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      # 1단계: 코드 가져오기
      - name: Checkout
        uses: actions/checkout@v4

      # 2단계: 런타임 환경 설정
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'          # npm 캐시 자동 활성화

      # 3단계: 의존성 설치
      - name: Install dependencies
        run: npm ci             # npm install 대신 ci (더 빠르고 정확)

      # 4단계: 코드 품질 검사
      - name: Lint
        run: npm run lint

      # 5단계: 테스트
      - name: Test
        run: npm test

      # 6단계: 빌드
      - name: Build
        run: npm run build
```

> 💡 **알고 계셨나요?**: `npm ci`는 `npm install`보다 **2~3배 빠릅니다**. `package-lock.json`을 그대로 사용하고 `node_modules`를 매번 새로 생성하기 때문에, CI 환경에서 일관된 결과를 보장해요. CI에서는 항상 `npm ci`를 쓰세요!

### 개념 3: 매트릭스 빌드

> 💡 **비유**: 매트릭스 빌드는 **한 번에 여러 시험장에서 동시에 시험 보기**입니다. Node 18, 20, 22 각 버전에서, Ubuntu, macOS, Windows 각 OS에서 — 총 9개 조합을 **동시에** 테스트합니다.

```yaml
jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        node-version: [18, 20, 22]
      fail-fast: false  # 하나 실패해도 나머지 계속 실행

    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      - run: npm ci
      - run: npm test
```

이 설정은 **3 OS x 3 Node = 9개 Job**을 동시에 실행합니다!

**매트릭스 활용 팁:**

```yaml
strategy:
  matrix:
    node-version: [18, 20, 22]
    # 특정 조합 추가
    include:
      - node-version: 22
        experimental: true     # 실험적 버전 표시
    # 특정 조합 제외
    exclude:
      - os: windows-latest
        node-version: 18       # Windows + Node 18 조합 제외
```

> ⚠️ **흔한 오해**: "매트릭스를 많이 만들수록 좋다" — 주의하세요! 3 x 3 x 3 매트릭스는 27개 Job이 동시에 실행됩니다. 공개 저장소는 무료지만, **비공개 저장소에서는 비용이 27배**가 됩니다. 꼭 필요한 조합만 테스트하세요.

### 개념 4: 캐싱 — 빌드 속도 높이기

의존성을 매번 새로 설치하면 시간이 낭비됩니다. 캐싱으로 이를 해결합니다.

**방법 1: setup-* Action의 내장 캐시** (가장 간단)

```yaml
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'npm'    # package-lock.json 기반 자동 캐싱
```

**방법 2: actions/cache 직접 사용** (세밀한 제어)

```yaml
- name: Cache node_modules
  uses: actions/cache@v4
  with:
    path: node_modules
    key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}
    restore-keys: |
      ${{ runner.os }}-node-

- name: Install dependencies
  run: npm ci
```

캐시 동작 원리:

1. `key`가 정확히 일치하면 → 캐시 **적중(hit)**, 설치 건너뜀
2. `key`가 없으면 `restore-keys`로 **부분 일치** 시도
3. 완전히 없으면 → 새로 설치 후 캐시 **저장**

**언어별 캐시 설정 예시:**

```yaml
# Python — pip 캐시
- uses: actions/setup-python@v5
  with:
    python-version: '3.12'
    cache: 'pip'

# Java — Gradle 캐시
- uses: actions/setup-java@v4
  with:
    java-version: '21'
    distribution: 'temurin'
    cache: 'gradle'

# Go — 모듈 캐시
- uses: actions/setup-go@v5
  with:
    go-version: '1.22'
    cache: true
```

> 🔥 **실무 팁**: 캐시 적중률을 모니터링하세요. GitHub Actions 로그에서 "Cache hit" / "Cache miss"를 확인할 수 있습니다. 캐시 적중 시 Node.js 프로젝트 기준 **30~60초** 절약 가능합니다.

### 개념 5: 아티팩트(Artifacts)

빌드 결과물, 테스트 보고서, 커버리지 리포트 등을 **아티팩트**로 저장할 수 있습니다.

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npm run build

      # 빌드 결과 업로드
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: dist/
          retention-days: 7    # 7일간 보관

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci
      - run: npm test -- --coverage

      # 테스트 커버리지 리포트 업로드
      - name: Upload coverage
        uses: actions/upload-artifact@v4
        if: always()           # 테스트 실패해도 리포트 업로드
        with:
          name: coverage-report
          path: coverage/
```

```bash
# GitHub CLI로 아티팩트 다운로드
gh run download 1234567890 -n build-output
```

### 개념 6: PR 상태 체크와 브랜치 보호

CI가 PR과 연동되면, **코드 리뷰 전에 자동 검증**이 가능합니다.

저장소 Settings → Branches → Branch protection rules에서 설정:

1. **Require status checks to pass** — CI가 통과해야 머지 가능
2. **Require branches to be up to date** — 최신 base 브랜치와 동기화 필수

> 🔥 **실무 팁**: **Status badge**를 README에 추가하면 프로젝트의 CI 상태를 한눈에 보여줄 수 있습니다:

```markdown
![CI](https://github.com/{owner}/{repo}/actions/workflows/ci.yml/badge.svg)
```

## 실습: Python 프로젝트 CI 구축

Node.js 외에 Python 프로젝트도 해봅시다:

```yaml
# .github/workflows/python-ci.yml
name: Python CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10', '3.11', '3.12']

    steps:
      - uses: actions/checkout@v4

      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov flake8

      - name: Lint with flake8
        run: flake8 src/ --count --show-source --statistics

      - name: Test with pytest
        run: pytest --cov=src --cov-report=xml

      - name: Upload coverage
        if: matrix.python-version == '3.12'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-xml
          path: coverage.xml
```

## 더 깊이 알아보기

### CI의 역사

**지속적 통합(CI)**이라는 용어는 1991년 **Grady Booch**가 처음 사용했고, 2000년 **Martin Fowler**와 **Kent Beck**이 XP(Extreme Programming)의 핵심 실천법으로 정립했습니다.

초기에는 **CruiseControl**(2001)이 최초의 CI 서버였고, **Hudson**(2005) → **Jenkins**(2011)로 이어지며 CI가 대중화되었습니다. 이후 클라우드 기반 **Travis CI**(2011), **CircleCI**(2011)가 등장하면서 "서버 없는 CI" 시대가 열렸죠. GitHub Actions(2019)는 이 흐름의 정점으로, 코드와 CI가 한 곳에 있는 **통합 경험**을 제공합니다.

## 흔한 오해와 팁

> ⚠️ **흔한 오해**: "`fail-fast: true`가 항상 좋다" — 기본값인 `fail-fast: true`는 하나의 매트릭스 조합이 실패하면 나머지를 모두 취소합니다. 빠른 피드백에는 좋지만, **어떤 조합에서 실패하는지 전체 그림**을 보려면 `fail-fast: false`가 나을 수 있습니다.

> 🔥 **실무 팁**: CI 실행 시간이 길어지면 **Job을 분리**하세요. lint, test, build를 하나의 Job에 넣으면 lint에서 실패해도 전체가 다시 실행됩니다. 별도 Job으로 분리하면 **실패한 부분만 빠르게 확인**할 수 있습니다.

> 💡 **알고 계셨나요?**: GitHub Actions의 캐시 용량은 저장소당 **10GB**까지이며, 7일간 접근되지 않은 캐시는 자동 삭제됩니다. 오래된 캐시가 쌓이는 걱정은 하지 않아도 됩니다.

## 핵심 정리

| 개념 | 설명 |
|------|------|
| **CI** | 코드 변경마다 자동으로 빌드/테스트하는 개발 방식 |
| **파이프라인** | checkout → setup → install → lint → test → build |
| **매트릭스 빌드** | 여러 OS/버전 조합을 동시에 테스트 |
| **캐싱** | 의존성을 캐시하여 빌드 시간 단축 |
| **아티팩트** | 빌드 결과물/리포트를 저장하고 공유 |
| **`npm ci`** | CI에 최적화된 의존성 설치 명령 |
| **fail-fast** | 하나 실패 시 나머지 취소 여부 (기본: true) |
| **Status badge** | README에 CI 상태 표시 |
| **브랜치 보호** | CI 통과 필수로 설정하여 코드 품질 보장 |

## 다음 섹션 미리보기

CI로 코드 품질을 자동 검증하는 방법을 배웠습니다. 다음은 검증을 통과한 코드를 자동으로 **배포**하는 차례예요. [배포 자동화](./04-cd.md)에서는 CD 파이프라인을 구축하고, 환경별 배포 전략, 자동 릴리스, 아티팩트 관리까지 다룹니다.

## 참고 자료

- [GitHub Docs — 매트릭스 전략](https://docs.github.com/ko/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow) - 매트릭스 빌드 공식 가이드
- [GitHub Docs — 캐싱 의존성](https://docs.github.com/ko/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows) - 캐시 설정과 모범 사례
- [GitHub Docs — 아티팩트](https://docs.github.com/ko/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow) - 아티팩트 업로드/다운로드
- [Martin Fowler — Continuous Integration](https://martinfowler.com/articles/continuousIntegration.html) - CI 개념의 원전
- [GitHub Actions Starter Workflows](https://github.com/actions/starter-workflows) - 언어별 CI 템플릿 모음
